import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';

function nakedSingle(candidates) {
    const moves = [];
    candidates.forEach((cand, idx) => {
        if (cand.length === 1) {
            moves.push({ idx, value: cand[0] });
        }
    });
    return moves;
}

function hiddenSingle(candidates) {
    const moves = [];

    // 行（Row）
    for (let r = 0; r < GRID_LENGTH; r++) {
        const map = new Map();
        for (let c = 0; c < GRID_LENGTH; c++) {
            const idx = r * GRID_LENGTH + c;
            for (const n of candidates[idx]) {
                if (!map.has(n)) map.set(n, []);
                map.get(n).push(idx);
            }
        }
        for (const [n, idxs] of map) {
            if (idxs.length === 1) moves.push({ idx: idxs[0], value: n });
        }
    }

    // 列（Column）
    for (let c = 0; c < GRID_LENGTH; c++) {
        const map = new Map();
        for (let r = 0; r < GRID_LENGTH; r++) {
            const idx = r * GRID_LENGTH + c;
            for (const n of candidates[idx]) {
                if (!map.has(n)) map.set(n, []);
                map.get(n).push(idx);
            }
        }
        for (const [n, idxs] of map) {
            if (idxs.length === 1) moves.push({ idx: idxs[0], value: n });
        }
    }

    // 宫（Box）
    for (let br = 0; br < GRID_LENGTH; br += BOX_SIZE) {
        for (let bc = 0; bc < GRID_LENGTH; bc += BOX_SIZE) {
            const map = new Map();
            for (let r = br; r < br + BOX_SIZE; r++) {
                for (let c = bc; c < bc + BOX_SIZE; c++) {
                    const idx = r * GRID_LENGTH + c;
                    for (const n of candidates[idx]) {
                        if (!map.has(n)) map.set(n, []);
                        map.get(n).push(idx);
                    }
                }
            }
            for (const [n, idxs] of map) {
                if (idxs.length === 1) moves.push({ idx: idxs[0], value: n });
            }
        }
    }

    return moves;
}

/**
 * @param {number[][]} grid - The Sudoku grid as a 2D array (9x9).
 * @returns {number[][]} - A 1D array of 81 elements, where each element is an array of possible numbers for the corresponding cell.
 */
export function getPossibleNumber(grid) {
    const possiblenumbers = Array.from({ length: GRID_LENGTH }, () => []);

    for (let row = 0; row < SUDOKU_SIZE; row++) {
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            const cellIndex = row * SUDOKU_SIZE + col;

            // If the cell is already filled, its list of possible numbers is empty.
            if (grid[row][col] !== 0) {
                continue;
            }

            const usedNumbers = new Set();

            // Check row
            for (let k = 0; k < SUDOKU_SIZE; k++) {
                if (grid[row][k] !== 0) {
                    usedNumbers.add(grid[row][k]);
                }
            }

            // Check column
            for (let k = 0; k < SUDOKU_SIZE; k++) {
                if (grid[k][col] !== 0) {
                    usedNumbers.add(grid[k][col]);
                }
            }

            // Check 3x3 box
            const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;

            for (let r_box = boxStartRow; r_box < boxStartRow + BOX_SIZE; r_box++) {
                for (let c_box = boxStartCol; c_box < boxStartCol + BOX_SIZE; c_box++) {
                    if (grid[r_box][c_box] !== 0) {
                        usedNumbers.add(grid[r_box][c_box]);
                    }
                }
            }

            // Determine possible numbers for the current cell
            for (let num = 1; num <= SUDOKU_SIZE; num++) {
                if (!usedNumbers.has(num)) {
                    possiblenumbers[cellIndex].push(num);
                }
            }
        }
    }
    return possiblenumbers;
}

export function possibleNumberSolver(grid) {
    const candidate = getPossibleNumber(grid);

    const nakedMoves = nakedSingle(candidates);
    if (nakedMoves.length > 0) {
        // 随机选一个 Naked Single move 返回
        const move = nakedMoves[Math.floor(Math.random() * nakedMoves.length)];
        return move, "possibleNumber + nakedSingle";
    }

    const hiddenMoves = hiddenSingle(candidates);
    if (hiddenMoves.length > 0) {
        // 随机选一个 Hidden Single move 返回
        const move = hiddenMoves[Math.floor(Math.random() * hiddenMoves.length)];
        return move, "possibleNumber + hiddenMoves";
    }

    return null;
}

