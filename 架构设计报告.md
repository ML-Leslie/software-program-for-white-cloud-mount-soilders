# 数独乐乐架构设计报告

## 1 引言

### 1.1 目的

本文档旨在详细描述“数独乐乐”软件的整体架构设计，包括其高层组件、模块划分以及关键设计决策。本设计旨在满足数独乐乐的核心业务愿景，即提供一个适合初学者、功能丰富且易于扩展的数独游戏体验，同时支持高级算法策略的集成与验证。

### 1.2 范围

本文档涵盖数独乐乐的核心功能模块，包括游戏管理、棋盘与单元格模型、历史操作与回溯、数独求解策略体系、外部资源集成以及策略验证机制。本文档不涉及具体的UI/UX设计细节或部署环境。

## 2 系统概述

### 2.1 业务愿景

“数独乐乐”旨在成为一款用户友好的数独游戏应用，尤其注重提升初学者的游戏体验。它将提供清晰的“下一步提示”和“提示线索”，帮助玩家理解数独解题逻辑。同时，通过集成SudokuWiki.org的资源和算法，确保应用能够持续提升求解能力并支持开发者的算法验证与新策略集成。

### 2.2 主要功能

* **游戏生命周期管理**：开始新游戏，进行游戏，结束游戏；
* **基本操作**：数字输入/修改、撤销、重输；
* **智能提示** ：提供下一步最佳解法提示，并附带详细的策略线索；
* **探索与回溯** ：允许玩家尝试不同可能，并在需要时回溯到之前的分支点；
* **题目导入** ：支持从SudokuWiki.org等平台通过URL导入谜题；
* **算法策略管理** ：支持集成、管理和验证多种数独求解算法策略。

## 3 系统架构

> 数独乐乐系统采用分层架构设计，旨在实现高内聚、低耦合，提高系统的可维护性、可扩展性和可测试性。

### 3.1 整体架构视图

系统主要分为以下几个逻辑层：

* **表现层（用户界面）**：
  * **职责**：负责用户界面的呈现和用户交互的处理。它接收用户的输入，并将数据传递给应用逻辑层；同时，它将应用逻辑层返回的结果以友好的方式展示给用户；
  * **组件**：主要是包装完的app组件，包括游戏棋盘UI、数字输入键盘、提示按钮、撤销/重做按钮、导入界面等；
  * **与应用逻辑层的关系**：通过定义清晰的接口与应用逻辑层交互。
* **应用逻辑层（业务层）**：
  * **职责**：封装核心业务逻辑和数据。它包含了系统中最核心的数独游戏规则、状态管理和策略实现的组件。
  * **核心组件**：
    * **Board**：数独棋盘相关的组件；
      * **Candidates**：构建候选数字网络的组件；
      * **Cell**：描述单元格状态的组件；
    * **Controls**：底部操作栏有关的组件；
      * **ActionBar**：底部操作栏有关的容器组件；
      * **keyboaed**：实现数独键盘功能的组件；
    * **Header**：顶部导航栏相关的组件；
      * **Buttons**：实现顶部按钮功能的组件；
      * **Dropdown**：实现下拉菜单功能的组件；
    * **Modal**：弹窗相关的组件，负责处理各种类型的弹窗及其内容；
    * **Utils**：通用功能类组件，如剪切板、开关等。
  * **与基础设施层的关系**：领域模型可能会使用基础设施层提供的服务（如历史管理、策略执行器）。
* **基础设施层（服务层）**：
  * **职责**：提供通用的技术服务和支持功能，不包含具体的业务逻辑。这些服务支撑着应用逻辑层和领域模型层；
  * **核心组件**：
    * **branchPoints**：提供创建分支点的功能，便于后续进行回溯和重做；
    * **history**：实现历史管理，支撑branchPoints的功能；
    * **game**：提供gamePaused和gameWon两个关键变量，控制游戏的进行/暂停以及游戏是否完成；
    * **hints**：实现下一步提示的功能；
    * **solver**：是继承了所有数独策略的接口，后续集成新数度策略也在这里面进行；
      * **nakedSingle**：利用裸单元法（naked single）找出每个候选数组中只有唯一候选数字的情况，将这些情况收集为一个 move 列表；
      * **hiddenSingle**：利用隐单法（hidden single）找出某一单位（行、列或盒）中唯一可填的数字，将这些情况加入到 move 列表中；
      * **getOnePossibleNumber**：根据给定的棋盘状态（二维数组），获取指定单元格（由 cellIndex 指定）的可能填入数字；
      * **getPossibleNumber**：计算整个数独棋盘中每个空白单元格的可能填入数字集合。
  * 与外部系统的关系：会与 SudokuWiki.org 等外部资源进行交互。

### 3.2 模块划分

> 根据功能职责，系统可进一步划分为以下主要模块：

* **游戏核心模块**：
  * **包含**：Board、Cell、grid等，负责数独棋盘的表示、状态维护和基本规则验证。
  * **职责**：管理数独游戏的数据模型。
* **操作历史模块**：
  * **包含**：history、branchPoints、record等。
  * **职责**：实现撤销/重做功能，并支持探索模式下的分支保存和回溯。采用命令模式和备忘录模式。
* **数独策略模块**：
  * **包含**：solver接口以及其中策略的具体实现，如nakedSingle、hiddenSingle等。
  * **职责**：提供可插拔的数独求解算法，生成“下一步提示”和“提示线索”。采用策略模式。
* **外部集成模块**：
  * **包含**：sencode接口及其包含的具体解码方式。
  * **职责**：负责与外部数独资源（如SudokuWiki.org）进行交互，导入题目数据。

## 4 关键设计决策

### 4.1 面向对象设计原则

* **单一职责原则 (SRP)** ：每个类和模块都应只负责一项功能。例如，Board 负责棋盘数据，History 负责历史操作，solver 负责单一的求解逻辑。
* **开放/封闭原则 (OCP)** ：对扩展开放，对修改封闭。数独求解策略通过 solver接口实现，新增策略无需修改接口的核心逻辑。
* **依赖倒置原则 (DIP)** ：高层模块不依赖低层模块，两者都依赖抽象。 app组件依赖 solver 接口而非具体策略类。

### 4.2 游戏状态管理

* **决策** ：引入 record 枚举来明确定义游戏在不同时间点的状态。
* **理由** ：这有助于清晰地管理游戏流程，确保用户界面和后台逻辑能够根据当前状态做出正确响应，避免状态混乱。

### 4.3 撤销/重做与探索回溯

* **决策** ：
  - 采用命令模式和备忘录模式实现操作历史的记录与恢复。每次用户对棋盘的操作（如填数、擦除、批量回溯）都会以 `{row, col, oldValue, newValue}` 的形式记录到 record 模块的 undo 栈中，支持撤销（undo）和重做（redo）功能。
  - 引入 branchPoints 模块，记录用户在探索模式下的分支点。当用户在解题过程中遇到分歧，可以主动创建分支点，后续若发现路径错误，可一键回溯到最近的分支点，实现探索式解题和回溯。
  - history 模块配合 branchPoints，记录每一步的光标位置和操作，便于回溯时快速定位和恢复状态。
  - 在 UI 层，撤销/重做、回溯等操作通过按钮触发，调用对应 store 的方法，自动同步界面和数据状态。
* **理由** ：
  - 通过命令模式和备忘录模式，能够灵活地管理用户的操作历史，支持多步撤销/重做，提升用户体验和容错能力。
  - 分支点机制让用户可以大胆尝试不同解题路径，遇到错误时无需手动逐步撤销，而是可以一键回溯到探索分支，提高解题效率和趣味性。
  - 这种设计将操作历史与分支点解耦，便于后续扩展更多探索和回溯相关功能，同时保证核心逻辑的清晰和可维护性。

### 4.4 数独求解策略体系

* **决策**：
  - 采用策略模式，将不同的数独求解算法（如裸单元法 nakedSingle、隐单元法 hiddenSingle 等）封装为独立的策略函数，通过统一的 solver 接口进行调用和扩展。
  - 提供 getPossibleNumber、getOnePossibleNumber 等通用工具函数，支持对棋盘状态的候选数分析和单元格可能值推断。
  - possibleNumberSolver 作为统一入口，自动选择可用的策略并返回下一步推荐操作及其策略说明，便于 UI 层直接调用并展示提示。
  - 所有策略均可插拔，后续新增策略时只需实现对应函数并注册到 solver 接口，无需修改现有核心逻辑。
* **理由**：
  - 策略模式便于维护和扩展不同的求解算法，支持多种解题思路的集成和切换，满足初学者和进阶玩家的不同需求。
  - 统一的接口和数据结构（如 move、candidates）简化了 UI 与算法层的交互，提升了代码的可读性和可测试性。
  - 通过策略说明（如“nakedSingle”、“hiddenSingle”），可以为用户提供详细的解题线索，增强学习和辅助体验。
### 4.5 外部资源集成

* **决策**：
  - 设计 sencode 接口，支持与外部数独资源（如 SudokuWiki.org）进行数据交互，实现题目的导入与导出。
  - 采用 base62 编码方案对题目数据进行压缩和解码，保证数据传输的高效性和兼容性。
  - 在应用启动时自动解析 URL hash 中的 sencode 字符串，校验合法性后作为初始题目导入，提升用户体验和题库扩展能力。
* **理由**：
  - 通过标准化的 sencode 编码和解码流程，能够无缝对接主流数独题库和社区资源，方便用户导入高质量题目。
  - base62 编码方案简洁高效，适合在 URL、剪贴板等场景下传递和分享题目数据。
  - 自动化的导入流程降低了用户操作门槛，增强了应用的开放性和可扩展性。